library dartcoin.test.wire.bloom_filter;



import "package:unittest/unittest.dart";

import "package:dartcoin/core/core.dart";





void _insertSerializeTest() {
  BloomFilter filter = new BloomFilter(3, 0.01, 0, BloomUpdate.UPDATE_ALL);
  
  filter.insert(CryptoUtils.hexToBytes("99108ad8ed9bb6274d3980bab5a85c048f0950c8"));
  expect(filter.contains(CryptoUtils.hexToBytes("99108ad8ed9bb6274d3980bab5a85c048f0950c8")), isTrue);
  // One bit different in first byte
  expect(filter.contains(CryptoUtils.hexToBytes("19108ad8ed9bb6274d3980bab5a85c048f0950c8")), isFalse);

  filter.insert(CryptoUtils.hexToBytes("b5a2c786d9ef4658287ced5914b37a1b4aa32eee"));
  expect(filter.contains(CryptoUtils.hexToBytes("b5a2c786d9ef4658287ced5914b37a1b4aa32eee")), isTrue);
  
  filter.insert(CryptoUtils.hexToBytes("b9300670b4c5366e95b2699e8b18bc75e5f729c5"));
  expect(filter.contains(CryptoUtils.hexToBytes("b9300670b4c5366e95b2699e8b18bc75e5f729c5")), isTrue);
  
  // Value generated by the reference client
  expect(CryptoUtils.bytesToHex(filter.serialize()), equals("03614e9b050000000000000001"));
}


void _insertSerializeTestWithTweak() {
  BloomFilter filter = new BloomFilter(3, 0.01, 2147483649);
  
  filter.insert(CryptoUtils.hexToBytes("99108ad8ed9bb6274d3980bab5a85c048f0950c8"));
  expect(filter.contains(CryptoUtils.hexToBytes("99108ad8ed9bb6274d3980bab5a85c048f0950c8")), isTrue);
  // One bit different in first byte
  expect(filter.contains(CryptoUtils.hexToBytes("19108ad8ed9bb6274d3980bab5a85c048f0950c8")), isFalse);

  filter.insert(CryptoUtils.hexToBytes("b5a2c786d9ef4658287ced5914b37a1b4aa32eee"));
  expect(filter.contains(CryptoUtils.hexToBytes("b5a2c786d9ef4658287ced5914b37a1b4aa32eee")), isTrue);
  
  filter.insert(CryptoUtils.hexToBytes("b9300670b4c5366e95b2699e8b18bc75e5f729c5"));
  expect(filter.contains(CryptoUtils.hexToBytes("b9300670b4c5366e95b2699e8b18bc75e5f729c5")), isTrue);
  
  // Value generated by the reference client
  expect(CryptoUtils.bytesToHex(filter.serialize()), equals("03ce4299050000000100008002"));
}


//void _walletTest() {
//  NetworkParameters params = MainNetParams.get();
//
//  DumpedPrivateKey privKey = new DumpedPrivateKey(params, "5Kg1gnAjaLfKiwhhPpGS3QfRg2m6awQvaj98JCZBZQ5SuS2F15C");
//  
//  Address addr = privKey.getKey().toAddress(params);
//  assertTrue(addr.toString().equals("17Wx1GQfyPTNWpQMHrTwRSMTCAonSiZx9e"));
//  
//  Wallet wallet = new Wallet(params);
//  // Check that the wallet was created with no keys
//  // If wallets ever get created with keys, this test needs redone.
//  for (ECKey key : wallet.getKeys())
//      fail();
//  wallet.addKey(privKey.getKey());
//  // Add a random key which happens to have been used in a recent generation
//  wallet.addKey(new ECKey(null, CryptoUtils.hexToBytes("03cb219f69f1b49468bd563239a86667e74a06fcba69ac50a08a5cbc42a5808e99")));
//  wallet.commitTx(new Transaction(params, CryptoUtils.hexToBytes("01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0d038754030114062f503253482fffffffff01c05e559500000000232103cb219f69f1b49468bd563239a86667e74a06fcba69ac50a08a5cbc42a5808e99ac00000000")));
//  
//  // We should have 2 per pubkey, and one for the pay-2-pubkey output we have
//  assertTrue(wallet.getBloomFilterElementCount() == 5);
//  
//  BloomFilter filter = wallet.getBloomFilter(wallet.getBloomFilterElementCount(), 0.001, 0);
//  
//  // Value generated by the reference client
//  assertTrue(Arrays.equals(CryptoUtils.hexToBytes("082ae5edc8e51d4a03080000000000000002"), filter.bitcoinSerialize()));
//}

void main() {
  group("wire.BloomFilter", () {
    test("insertSerialize", () => _insertSerializeTest());
    test("insertSerializeWithTweak", () => _insertSerializeTestWithTweak());
  });
}





